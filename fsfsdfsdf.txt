async def add_client_to_server(days, tg_id, email_count, email, server_id, sub_id=None, is_admin_user=False, total_gb=None):
    """
    Добавление клиента на определенный сервер.
    
    Эта функция объединяет логику для обычных и "своих" пользователей через параметр is_admin_user.
    
    :param days: Количество дней действия подписки
    :param tg_id: Telegram ID пользователя
    :param email_count: Порядковый номер email для данного пользователя
    :param email: Email пользователя
    :param server_id: ID сервера из SERVERS
    :param sub_id: Идентификатор подписки
    :param is_admin_user: Флаг, указывающий что это "свой" пользователь админа
    :param total_gb: Лимит трафика в ГБ (None = безлимитный трафик)
    :return: (success, message, subscription_link, vless_id, sub_id)
    """
    try:
        if not await ensure_authenticated(server_id):
            return False, "Авторизация не удалась", None, None, None
        
        server_config = SERVERS.get(server_id)
        if not server_config:
            return False, f"Конфигурация для сервера {server_id} не найдена", None, None, None
        
        # Формируем базовый URL для добавления клиента
        add_client_url = (
            f"http://{server_config['host']}:{server_config['port']}"
            f"{server_config['basepath']}/panel/api/inbounds/addClient"
        )
        
        # Расчет времени окончания подписки в миллисекундах с начала эпохи
        # Используем старую логику расчета времени для совместимости
        if is_admin_user:
            # Бессрочная подписка для "своих" пользователей (админов)
            expiry_time_ms = 0
        else:
            # Стандартный расчет expiry_time для обычных пользователей
            epoch = datetime.fromtimestamp(0, timezone.utc)
            current_time_ms = int((datetime.now(timezone.utc) - epoch).total_seconds() * 1000.0)
            expiry_time_ms = current_time_ms + (86400000 * days)
            
        # Расчет лимита трафика в байтах
        # По умолчанию безлимитный трафик для всех пользователей
        total_bytes = 0  # Безлимитный трафик (0 = безлимит в 3x-ui)

        # Если передан явный лимит трафика и это не админ, устанавливаем его
        if total_gb is not None and not is_admin_user:
            total_bytes = total_gb * 1024 * 1024 * 1024

        # Лимит IP
        if is_admin_user:
            limit_ip = 0  # Без ограничений по IP для админов
        else:
            limit_ip = 3  # Ограничение в 3 IP для обычных пользователей

        # Генерация уникального идентификатора клиента (vless_id)
        vless_id = str(uuid.uuid4())

        # Создание или использование существующего sub_id
        if not sub_id:
            # Генерируем новый sub_id на основе tg_id, срока действия и email_count
            if days == 30:
                sub_id = f"Sputnik-{tg_id}-{email_count}"
            elif days == 90:
                sub_id = f"Zemlyanin-{tg_id}-{email_count}"
            elif days == 180:
                sub_id = f"Astronaut-{tg_id}-{email_count}"
            # Можно добавить и другие варианты
        
        # Определяем, какой inboundId использовать
        inbound_id = 1  # Всегда используем inbound_id=1 для всех пользователей

        payload = {
            "id": inbound_id,
            "settings": json.dumps({
                "clients": [
                    {
                        "id": vless_id,
                        "flow": "xtls-rprx-vision",
                        "email": email,
                        "limitIp": limit_ip,
                        "totalGB": total_bytes,
                        "expiryTime": expiry_time_ms,
                        "enable": True,
                        "tgId": str(tg_id),
                        "subId": sub_id,
                        "reset": 0
                    }
                ]
            })
        }

        logging.info(f"Добавление клиента на {server_id}: days={days}, is_admin_user={is_admin_user}, expiry_time_ms={expiry_time_ms}, total_bytes={total_bytes}")

        headers = {"Accept": "application/json"}
        cookies = session_cookies.get(server_id, {})

        timeout = aiohttp.ClientTimeout(total=10)
        async with aiohttp.ClientSession(cookies=cookies, timeout=timeout) as session:
            try:
                async with session.post(add_client_url, json=payload, headers=headers) as response:
                    logging.info(f"HTTP статус ({server_id}): {response.status}")
                    if response.status == 200:
                        response_data = await response.json()
                        if response_data.get("success"):
                            logging.info(f"Клиент успешно добавлен на {server_id}: {response_data}")
                            subscription_link = generate_https_link(sub_id, server_id)
                            return True, f"Клиент успешно добавлен на {server_id}.", subscription_link, vless_id, sub_id
                        else:
                            error_msg = response_data.get("msg", "Неизвестная ошибка.")
                            logging.error(f"Ошибка добавления клиента на {server_id}: {error_msg}")
                            return False, error_msg, None, None, None
                    else:
                        error_text = await response.text()
                        logging.error(f"HTTP ошибка на {server_id}: {response.status}, {error_text[:500]}")
                        return False, f"HTTP ошибка: {response.status}.", None, None, None
            except asyncio.TimeoutError:
                logging.error(f"Таймаут при добавлении клиента в панель {server_id}")
                return False, f"Превышено время ожидания от панели {server_id}.", None, None, None
            except Exception as e:
                logging.error(f"Ошибка при добавлении клиента на {server_id}: {str(e)}")
                return False, f"Ошибка соединения с сервером {server_id}.", None, None, None
    except Exception as e:
        logging.error(f"Общая ошибка при добавлении клиента на {server_id}: {str(e)}")
        return False, f"Общая ошибка: {str(e)}", None, None, None